package com.rubberjam.protobuf.compiler.csharp;

import com.google.protobuf.Descriptors.FileDescriptor;
import com.google.protobuf.Descriptors.Descriptor;
import com.google.protobuf.Descriptors.EnumDescriptor;
import com.google.protobuf.Descriptors.FieldDescriptor;
import com.google.protobuf.Descriptors.OneofDescriptor;
import java.io.PrintWriter;
import java.util.Base64;
import java.util.ArrayList;
import java.util.List;

import com.google.protobuf.DescriptorProtos.FileDescriptorProto;

public class CSharpFileGenerator {
    private final FileDescriptor file;
    private final FileDescriptorProto fileProto;

    public CSharpFileGenerator(FileDescriptor file) {
        this(file, null);
    }

    public CSharpFileGenerator(FileDescriptor file, FileDescriptorProto fileProto) {
        this.file = file;
        this.fileProto = fileProto;
    }

    public void generate(PrintWriter writer) {
        writer.println("// <auto-generated>");
        writer.println("//     Generated by the protocol buffer compiler.  DO NOT EDIT!");
        writer.println("//     source: " + file.getName());
        writer.println("// </auto-generated>");
        writer.println("#pragma warning disable 1591, 0612, 3021, 8981");
        writer.println("#region Designer generated code");
        writer.println();
        writer.println("using pb = global::Google.Protobuf;");
        writer.println("using pbc = global::Google.Protobuf.Collections;");
        writer.println("using pbr = global::Google.Protobuf.Reflection;");
        writer.println("using scg = global::System.Collections.Generic;");
        String namespace = file.getPackage();
        if (!namespace.isEmpty()) {
            writer.println("namespace " + toPascalCase(namespace) + " {");
            writer.println();
        }

        generateReflectionClass(writer);

        for (com.google.protobuf.Descriptors.Descriptor messageType : file.getMessageTypes()) {
            writer.println("  public sealed partial class " + messageType.getName() + " : pb::IMessage<" + messageType.getName() + "> {");
            writer.println("    private static readonly pb::MessageParser<" + messageType.getName() + "> _parser = new pb::MessageParser<" + messageType.getName() + ">(() => new " + messageType.getName() + "());");
            writer.println("    private pb::UnknownFieldSet _unknownFields;");
            writer.println("    public static pb::MessageParser<" + messageType.getName() + "> Parser { get { return _parser; } }");
            writer.println("    public static pbr::MessageDescriptor Descriptor { get { return null; } }");
            writer.println("    pbr::MessageDescriptor pb::IMessage.Descriptor { get { return Descriptor; } }");
            writer.println("    public " + messageType.getName() + "() { }");
            writer.println("    public " + messageType.getName() + "(" + messageType.getName() + " other) : this() { }");
            writer.println("    public " + messageType.getName() + " Clone() { return new " + messageType.getName() + "(this); }");
            writer.println("    public void WriteTo(pb::CodedOutputStream output) { }");
            writer.println("    public int CalculateSize() { return 0; }");
            writer.println("    public void MergeFrom(" + messageType.getName() + " other) { }");
            writer.println("    public void MergeFrom(pb::CodedInputStream input) { }");
            writer.println("    public bool Equals(" + messageType.getName() + " other) { return true; }");
            writer.println("    public override bool Equals(object other) { return Equals(other as " + messageType.getName() + "); }");
            writer.println("    public override int GetHashCode() { return 0; }");
            writer.println("    public override string ToString() { return \"\"; }");
            writer.println("  }");
            writer.println();
        }

        if (!namespace.isEmpty()) {
            writer.println("}");
            writer.println();
        }
        writer.println("#endregion Designer generated code");
    }

    private void generateReflectionClass(PrintWriter writer) {
        String filename = file.getName();
        String basename = filename;
        int lastSlash = basename.lastIndexOf('/');
        if (lastSlash != -1) {
            basename = basename.substring(lastSlash + 1);
        }
        if (basename.endsWith(".proto")) {
            basename = basename.substring(0, basename.length() - 6);
        }
        String reflectionClassName = toPascalCase(basename) + "Reflection";

        writer.println("  /// <summary>Holder for reflection information generated from " + filename + "</summary>");
        writer.println("  public static partial class " + reflectionClassName + " {");
        writer.println();
        writer.println("    #region Descriptor");
        writer.println("    /// <summary>File descriptor for " + filename + "</summary>");
        writer.println("    public static pbr::FileDescriptor Descriptor {");
        writer.println("      get { return descriptor; }");
        writer.println("    }");
        writer.println("    private static pbr::FileDescriptor descriptor;");
        writer.println();
        writer.println("    static " + reflectionClassName + "() {");
        writer.println("      byte[] descriptorData = global::System.Convert.FromBase64String(");
        writer.println("          string.Concat(");

        byte[] bytes;
        if (fileProto != null) {
            bytes = fileProto.toByteArray();
        } else {
            bytes = file.toProto().toByteArray();
        }
        String base64 = Base64.getEncoder().encodeToString(bytes);
        int chunkSize = 60; // C# compiler often prefers shorter strings
        for (int i = 0; i < base64.length(); i += chunkSize) {
            String chunk = base64.substring(i, Math.min(i + chunkSize, base64.length()));
            writer.println("            \"" + chunk + "\"" + (i + chunkSize < base64.length() ? "," : ""));
        }
        writer.println("));");

        writer.println("      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,");
        writer.print("          new pbr::FileDescriptor[] {");
        for (FileDescriptor dependency : file.getDependencies()) {
             // We need to access the reflection class of the dependency.
             // Assuming similar naming convention.
             String depFilename = dependency.getName();
             String depBasename = depFilename;
             int depLastSlash = depBasename.lastIndexOf('/');
             if (depLastSlash != -1) {
                 depBasename = depBasename.substring(depLastSlash + 1);
             }
             if (depBasename.endsWith(".proto")) {
                 depBasename = depBasename.substring(0, depBasename.length() - 6);
             }
             String depReflectionClass = toPascalCase(depBasename) + "Reflection";
             String depNamespace = dependency.getPackage();
             String fullDepClass = "global::" + (depNamespace.isEmpty() ? "" : toPascalCase(depNamespace) + ".") + depReflectionClass;
             writer.print(" " + fullDepClass + ".Descriptor,");
        }
        writer.println(" },");

        // GeneratedClrTypeInfo
        writer.println("          new pbr::GeneratedClrTypeInfo(new[] {");
        for (EnumDescriptor enumDesc : file.getEnumTypes()) {
            writer.println("            typeof(" + getClassName(enumDesc) + "), ");
        }
        writer.println("          }, null, new pbr::GeneratedClrTypeInfo[] {");
        for (Descriptor messageDesc : file.getMessageTypes()) {
            generateMessageClrTypeInfo(writer, messageDesc);
            writer.println(",");
        }
        writer.println("          }));");
        writer.println("    }");
        writer.println("    #endregion");
        writer.println();
        writer.println("  }");
    }

    private void generateMessageClrTypeInfo(PrintWriter writer, Descriptor messageDescriptor) {
        String className = getClassName(messageDescriptor);
        writer.print("            new pbr::GeneratedClrTypeInfo(typeof(" + className + "), " + className + ".Parser, ");

        // propertyNames
        if (messageDescriptor.getFields().isEmpty()) {
            writer.print("null, ");
        } else {
            writer.print("new[]{ ");
            for (FieldDescriptor field : messageDescriptor.getFields()) {
                writer.print("\"" + getPropertyName(field) + "\", ");
            }
            writer.print("}, ");
        }

        // oneofNames
        if (messageDescriptor.getRealOneofs().isEmpty()) {
             // For proto3 optionals, they are synthetic oneofs.
             // We need to check if there are any synthetic oneofs that act as optionals?
             // The expected output includes "OptionalString", etc in the second array.
             // Descriptors.OneofDescriptor has options.
             // But wait, getOneofs() returns all oneofs including synthetic.
             // getRealOneofs() returns only real oneofs.
             // C# generator seems to include all oneofs in this list?
             // Let's check OneofMessageV3 in expected output.
             // new[]{ "TestOneof", "SecondOneof" } -> These are real oneofs.
             // AllFieldTypesV3: new[]{ "OptionalString", ... } -> These are synthetic oneofs.
             // So we should use getOneofs().
             if (messageDescriptor.getOneofs().isEmpty()) {
                 writer.print("null, ");
             } else {
                 writer.print("new[]{ ");
                 for (OneofDescriptor oneof : messageDescriptor.getOneofs()) {
                     writer.print("\"" + toPascalCase(oneof.getName()) + "\", ");
                 }
                 writer.print("}, ");
             }
        } else {
             writer.print("new[]{ ");
             for (OneofDescriptor oneof : messageDescriptor.getOneofs()) {
                 writer.print("\"" + toPascalCase(oneof.getName()) + "\", ");
             }
             writer.print("}, ");
        }

        // nestedEnums
        if (messageDescriptor.getEnumTypes().isEmpty()) {
            writer.print("null, ");
        } else {
             writer.print("new[]{ ");
             for (EnumDescriptor enumDesc : messageDescriptor.getEnumTypes()) {
                 writer.print("typeof(" + getClassName(enumDesc) + "), ");
             }
             writer.print("}, ");
        }

        // nestedExtensions
        writer.print("null, ");

        // nestedTypes
        if (messageDescriptor.getNestedTypes().isEmpty()) {
             writer.print("null");
        } else {
             writer.print("new pbr::GeneratedClrTypeInfo[] { ");
             for (Descriptor nested : messageDescriptor.getNestedTypes()) {
                 if (nested.getOptions().getMapEntry()) {
                     writer.print("null, ");
                 } else {
                     generateMessageClrTypeInfo(writer, nested);
                     writer.print(", ");
                 }
             }
             writer.print("}");
        }

        writer.print(")");
    }

    private String getClassName(Descriptor descriptor) {
        return "global::" + (descriptor.getFile().getPackage().isEmpty() ? "" : toPascalCase(descriptor.getFile().getPackage()) + ".") + getNestedClassName(descriptor);
    }

    private String getNestedClassName(Descriptor descriptor) {
        if (descriptor.getContainingType() != null) {
            return getNestedClassName(descriptor.getContainingType()) + ".Types." + descriptor.getName();
        }
        return descriptor.getName();
    }

    private String getClassName(EnumDescriptor descriptor) {
        return "global::" + (descriptor.getFile().getPackage().isEmpty() ? "" : toPascalCase(descriptor.getFile().getPackage()) + ".") + getNestedClassName(descriptor);
    }

    private String getNestedClassName(EnumDescriptor descriptor) {
        if (descriptor.getContainingType() != null) {
            return getNestedClassName(descriptor.getContainingType()) + ".Types." + descriptor.getName();
        }
        return descriptor.getName();
    }

    private String getPropertyName(FieldDescriptor field) {
        String name = field.getName();
        // Handle special casing if needed.
        // For now just PascalCase.
        return toPascalCase(name);
    }

    private String toPascalCase(String name) {
        StringBuilder sb = new StringBuilder();
        boolean up = true;
        for (char c : name.toCharArray()) {
            if (c == '_' || c == '.' || c == '-') {
                if (c == '.') {
                    sb.append('.');
                    up = true;
                } else {
                    up = true;
                }
            } else {
                if (up) {
                    sb.append(Character.toUpperCase(c));
                    up = false;
                } else {
                    sb.append(c);
                }
            }
        }
        return sb.toString();
    }
}
