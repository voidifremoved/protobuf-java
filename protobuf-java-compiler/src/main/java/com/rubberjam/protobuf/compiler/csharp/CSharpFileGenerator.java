package com.rubberjam.protobuf.compiler.csharp;

import com.google.protobuf.Descriptors.FileDescriptor;
import java.io.PrintWriter;

public class CSharpFileGenerator {
    private final FileDescriptor file;

    public CSharpFileGenerator(FileDescriptor file) {
        this.file = file;
    }

    public void generate(PrintWriter writer) {
        writer.println("// <auto-generated>");
        writer.println("//     Generated by the protocol buffer compiler.  DO NOT EDIT!");
        writer.println("//     source: " + file.getName());
        writer.println("// </auto-generated>");
        writer.println();
        writer.println("using pb = global::Google.Protobuf;");
        writer.println("using pbc = global::Google.Protobuf.Collections;");
        writer.println("using pbr = global::Google.Protobuf.Reflection;");
        writer.println("using scg = global::System.Collections.Generic;");
        writer.println();

        String namespace = file.getPackage();
        if (!namespace.isEmpty()) {
            writer.println("namespace " + toPascalCase(namespace) + " {");
            writer.println();
        }

        for (com.google.protobuf.Descriptors.Descriptor messageType : file.getMessageTypes()) {
            writer.println("  public sealed partial class " + messageType.getName() + " : pb::IMessage<" + messageType.getName() + "> {");
            writer.println("    private static readonly pb::MessageParser<" + messageType.getName() + "> _parser = new pb::MessageParser<" + messageType.getName() + ">(() => new " + messageType.getName() + "());");
            writer.println("    private pb::UnknownFieldSet _unknownFields;");
            writer.println("    public static pb::MessageParser<" + messageType.getName() + "> Parser { get { return _parser; } }");
            writer.println("    public static pbr::MessageDescriptor Descriptor { get { return null; } }");
            writer.println("    pbr::MessageDescriptor pb::IMessage.Descriptor { get { return Descriptor; } }");
            writer.println("    public " + messageType.getName() + "() { }");
            writer.println("    public " + messageType.getName() + "(" + messageType.getName() + " other) : this() { }");
            writer.println("    public " + messageType.getName() + " Clone() { return new " + messageType.getName() + "(this); }");
            writer.println("    public void WriteTo(pb::CodedOutputStream output) { }");
            writer.println("    public int CalculateSize() { return 0; }");
            writer.println("    public void MergeFrom(" + messageType.getName() + " other) { }");
            writer.println("    public void MergeFrom(pb::CodedInputStream input) { }");
            writer.println("    public bool Equals(" + messageType.getName() + " other) { return true; }");
            writer.println("    public override bool Equals(object other) { return Equals(other as " + messageType.getName() + "); }");
            writer.println("    public override int GetHashCode() { return 0; }");
            writer.println("    public override string ToString() { return \"\"; }");
            writer.println("  }");
            writer.println();
        }

        if (!namespace.isEmpty()) {
            writer.println("}");
            writer.println();
        }
    }

    private String toPascalCase(String name) {
        StringBuilder sb = new StringBuilder();
        boolean up = true;
        for (char c : name.toCharArray()) {
            if (c == '_' || c == '.' || c == '-') {
                if (c == '.') {
                    sb.append('.');
                    up = true;
                } else {
                    up = true;
                }
            } else {
                if (up) {
                    sb.append(Character.toUpperCase(c));
                    up = false;
                } else {
                    sb.append(c);
                }
            }
        }
        return sb.toString();
    }
}
