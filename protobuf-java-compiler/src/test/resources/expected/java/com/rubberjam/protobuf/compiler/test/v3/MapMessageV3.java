// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: comprehensive_test_v3.proto
// Protobuf Java Version: 4.33.4

package com.rubberjam.protobuf.compiler.test.v3;

/**
 * <pre>
 * Message with map fields (proto3)
 * </pre>
 *
 * Protobuf type {@code ComprehensiveTest.V3.MapMessageV3}
 */
@com.google.protobuf.Generated
public final class MapMessageV3 extends
    com.google.protobuf.GeneratedMessage implements
    // @@protoc_insertion_point(message_implements:ComprehensiveTest.V3.MapMessageV3)
    MapMessageV3OrBuilder {
private static final long serialVersionUID = 0L;
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 33,
      /* patch= */ 4,
      /* suffix= */ "",
      "MapMessageV3");
  }
  // Use MapMessageV3.newBuilder() to construct.
  private MapMessageV3(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
    super(builder);
  }
  private MapMessageV3() {
  }

  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  @java.lang.Override
  protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
      int number) {
    switch (number) {
      case 1:
        return internalGetStringToInt32();
      case 2:
        return internalGetInt32ToString();
      case 3:
        return internalGetStringToEnum();
      case 4:
        return internalGetStringToMessage();
      case 5:
        return internalGetBoolToString();
      case 6:
        return internalGetInt64ToBytes();
      case 7:
        return internalGetUint32ToFloat();
      case 8:
        return internalGetFixed64ToDouble();
      default:
        throw new RuntimeException(
            "Invalid map field number: " + number);
    }
  }
  @java.lang.Override
  protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.rubberjam.protobuf.compiler.test.v3.MapMessageV3.class, com.rubberjam.protobuf.compiler.test.v3.MapMessageV3.Builder.class);
  }

  public static final int STRING_TO_INT32_FIELD_NUMBER = 1;
  private static final class StringToInt32DefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, java.lang.Integer> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, java.lang.Integer>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_StringToInt32Entry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.INT32,
                0);
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.String, java.lang.Integer> stringToInt32_;
  private com.google.protobuf.MapField<java.lang.String, java.lang.Integer>
  internalGetStringToInt32() {
    if (stringToInt32_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          StringToInt32DefaultEntryHolder.defaultEntry);
    }
    return stringToInt32_;
  }
  public int getStringToInt32Count() {
    return internalGetStringToInt32().getMap().size();
  }
  /**
   * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
   */
  @java.lang.Override
  public boolean containsStringToInt32(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    return internalGetStringToInt32().getMap().containsKey(key);
  }
  /**
   * Use {@link #getStringToInt32Map()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32() {
    return getStringToInt32Map();
  }
  /**
   * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32Map() {
    return internalGetStringToInt32().getMap();
  }
  /**
   * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
   */
  @java.lang.Override
  public int getStringToInt32OrDefault(
      java.lang.String key,
      int defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.Integer> map =
        internalGetStringToInt32().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
   */
  @java.lang.Override
  public int getStringToInt32OrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.Integer> map =
        internalGetStringToInt32().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int INT32_TO_STRING_FIELD_NUMBER = 2;
  private static final class Int32ToStringDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.Integer, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.Integer, java.lang.String>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_Int32ToStringEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.INT32,
                0,
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.Integer, java.lang.String> int32ToString_;
  private com.google.protobuf.MapField<java.lang.Integer, java.lang.String>
  internalGetInt32ToString() {
    if (int32ToString_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          Int32ToStringDefaultEntryHolder.defaultEntry);
    }
    return int32ToString_;
  }
  public int getInt32ToStringCount() {
    return internalGetInt32ToString().getMap().size();
  }
  /**
   * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
   */
  @java.lang.Override
  public boolean containsInt32ToString(
      int key) {

    return internalGetInt32ToString().getMap().containsKey(key);
  }
  /**
   * Use {@link #getInt32ToStringMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToString() {
    return getInt32ToStringMap();
  }
  /**
   * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToStringMap() {
    return internalGetInt32ToString().getMap();
  }
  /**
   * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
   */
  @java.lang.Override
  public /* nullable */
java.lang.String getInt32ToStringOrDefault(
      int key,
      /* nullable */
java.lang.String defaultValue) {

    java.util.Map<java.lang.Integer, java.lang.String> map =
        internalGetInt32ToString().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
   */
  @java.lang.Override
  public java.lang.String getInt32ToStringOrThrow(
      int key) {

    java.util.Map<java.lang.Integer, java.lang.String> map =
        internalGetInt32ToString().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int STRING_TO_ENUM_FIELD_NUMBER = 3;
  private static final class StringToEnumDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, java.lang.Integer> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, java.lang.Integer>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_StringToEnumEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.ENUM,
                com.rubberjam.protobuf.compiler.test.v3.TestEnumV3.TEST_UNKNOWN.getNumber());
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.String, java.lang.Integer> stringToEnum_;
  private com.google.protobuf.MapField<java.lang.String, java.lang.Integer>
  internalGetStringToEnum() {
    if (stringToEnum_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          StringToEnumDefaultEntryHolder.defaultEntry);
    }
    return stringToEnum_;
  }
  private static final
  com.google.protobuf.Internal.MapAdapter.Converter<
      java.lang.Integer, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3> stringToEnumValueConverter =
          com.google.protobuf.Internal.MapAdapter.newEnumConverter(
              com.rubberjam.protobuf.compiler.test.v3.TestEnumV3.internalGetValueMap(),
              com.rubberjam.protobuf.compiler.test.v3.TestEnumV3.UNRECOGNIZED);
  private static final java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3>
  internalGetAdaptedStringToEnumMap(
      java.util.Map<java.lang.String, java.lang.Integer> map) {
    return new com.google.protobuf.Internal.MapAdapter<
        java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3, java.lang.Integer>(
            map, stringToEnumValueConverter);
  }
  public int getStringToEnumCount() {
    return internalGetStringToEnum().getMap().size();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public boolean containsStringToEnum(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    return internalGetStringToEnum().getMap().containsKey(key);
  }
  /**
   * Use {@link #getStringToEnumMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3>
  getStringToEnum() {
    return getStringToEnumMap();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3>
  getStringToEnumMap() {
    return internalGetAdaptedStringToEnumMap(
        internalGetStringToEnum().getMap());}
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public /* nullable */
com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 getStringToEnumOrDefault(
      java.lang.String key,
      /* nullable */
com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.Integer> map =
        internalGetStringToEnum().getMap();
    return map.containsKey(key)
           ? stringToEnumValueConverter.doForward(map.get(key))
           : defaultValue;
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 getStringToEnumOrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.Integer> map =
        internalGetStringToEnum().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return stringToEnumValueConverter.doForward(map.get(key));
  }
  /**
   * Use {@link #getStringToEnumValueMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.Integer>
  getStringToEnumValue() {
    return getStringToEnumValueMap();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, java.lang.Integer>
  getStringToEnumValueMap() {
    return internalGetStringToEnum().getMap();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public int getStringToEnumValueOrDefault(
      java.lang.String key,
      int defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.Integer> map =
        internalGetStringToEnum().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
   */
  @java.lang.Override
  public int getStringToEnumValueOrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, java.lang.Integer> map =
        internalGetStringToEnum().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int STRING_TO_MESSAGE_FIELD_NUMBER = 4;
  private static final class StringToMessageDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_StringToMessageEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.getDefaultInstance());
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> stringToMessage_;
  private com.google.protobuf.MapField<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3>
  internalGetStringToMessage() {
    if (stringToMessage_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          StringToMessageDefaultEntryHolder.defaultEntry);
    }
    return stringToMessage_;
  }
  public int getStringToMessageCount() {
    return internalGetStringToMessage().getMap().size();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
   */
  @java.lang.Override
  public boolean containsStringToMessage(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    return internalGetStringToMessage().getMap().containsKey(key);
  }
  /**
   * Use {@link #getStringToMessageMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> getStringToMessage() {
    return getStringToMessageMap();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> getStringToMessageMap() {
    return internalGetStringToMessage().getMap();
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
   */
  @java.lang.Override
  public /* nullable */
com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 getStringToMessageOrDefault(
      java.lang.String key,
      /* nullable */
com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 defaultValue) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> map =
        internalGetStringToMessage().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
   */
  @java.lang.Override
  public com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 getStringToMessageOrThrow(
      java.lang.String key) {
    if (key == null) { throw new NullPointerException("map key"); }
    java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> map =
        internalGetStringToMessage().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int BOOL_TO_STRING_FIELD_NUMBER = 5;
  private static final class BoolToStringDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.Boolean, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.Boolean, java.lang.String>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_BoolToStringEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.BOOL,
                false,
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.Boolean, java.lang.String> boolToString_;
  private com.google.protobuf.MapField<java.lang.Boolean, java.lang.String>
  internalGetBoolToString() {
    if (boolToString_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          BoolToStringDefaultEntryHolder.defaultEntry);
    }
    return boolToString_;
  }
  public int getBoolToStringCount() {
    return internalGetBoolToString().getMap().size();
  }
  /**
   * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
   */
  @java.lang.Override
  public boolean containsBoolToString(
      boolean key) {

    return internalGetBoolToString().getMap().containsKey(key);
  }
  /**
   * Use {@link #getBoolToStringMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Boolean, java.lang.String> getBoolToString() {
    return getBoolToStringMap();
  }
  /**
   * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.Boolean, java.lang.String> getBoolToStringMap() {
    return internalGetBoolToString().getMap();
  }
  /**
   * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
   */
  @java.lang.Override
  public /* nullable */
java.lang.String getBoolToStringOrDefault(
      boolean key,
      /* nullable */
java.lang.String defaultValue) {

    java.util.Map<java.lang.Boolean, java.lang.String> map =
        internalGetBoolToString().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
   */
  @java.lang.Override
  public java.lang.String getBoolToStringOrThrow(
      boolean key) {

    java.util.Map<java.lang.Boolean, java.lang.String> map =
        internalGetBoolToString().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int INT64_TO_BYTES_FIELD_NUMBER = 6;
  private static final class Int64ToBytesDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.Long, com.google.protobuf.ByteString> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.Long, com.google.protobuf.ByteString>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_Int64ToBytesEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.INT64,
                0L,
                com.google.protobuf.WireFormat.FieldType.BYTES,
                com.google.protobuf.ByteString.EMPTY);
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.Long, com.google.protobuf.ByteString> int64ToBytes_;
  private com.google.protobuf.MapField<java.lang.Long, com.google.protobuf.ByteString>
  internalGetInt64ToBytes() {
    if (int64ToBytes_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          Int64ToBytesDefaultEntryHolder.defaultEntry);
    }
    return int64ToBytes_;
  }
  public int getInt64ToBytesCount() {
    return internalGetInt64ToBytes().getMap().size();
  }
  /**
   * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
   */
  @java.lang.Override
  public boolean containsInt64ToBytes(
      long key) {

    return internalGetInt64ToBytes().getMap().containsKey(key);
  }
  /**
   * Use {@link #getInt64ToBytesMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getInt64ToBytes() {
    return getInt64ToBytesMap();
  }
  /**
   * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getInt64ToBytesMap() {
    return internalGetInt64ToBytes().getMap();
  }
  /**
   * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
   */
  @java.lang.Override
  public /* nullable */
com.google.protobuf.ByteString getInt64ToBytesOrDefault(
      long key,
      /* nullable */
com.google.protobuf.ByteString defaultValue) {

    java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
        internalGetInt64ToBytes().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getInt64ToBytesOrThrow(
      long key) {

    java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
        internalGetInt64ToBytes().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int UINT32_TO_FLOAT_FIELD_NUMBER = 7;
  private static final class Uint32ToFloatDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.Integer, java.lang.Float> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.Integer, java.lang.Float>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_Uint32ToFloatEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.UINT32,
                0,
                com.google.protobuf.WireFormat.FieldType.FLOAT,
                0F);
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.Integer, java.lang.Float> uint32ToFloat_;
  private com.google.protobuf.MapField<java.lang.Integer, java.lang.Float>
  internalGetUint32ToFloat() {
    if (uint32ToFloat_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          Uint32ToFloatDefaultEntryHolder.defaultEntry);
    }
    return uint32ToFloat_;
  }
  public int getUint32ToFloatCount() {
    return internalGetUint32ToFloat().getMap().size();
  }
  /**
   * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
   */
  @java.lang.Override
  public boolean containsUint32ToFloat(
      int key) {

    return internalGetUint32ToFloat().getMap().containsKey(key);
  }
  /**
   * Use {@link #getUint32ToFloatMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Integer, java.lang.Float> getUint32ToFloat() {
    return getUint32ToFloatMap();
  }
  /**
   * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.Integer, java.lang.Float> getUint32ToFloatMap() {
    return internalGetUint32ToFloat().getMap();
  }
  /**
   * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
   */
  @java.lang.Override
  public float getUint32ToFloatOrDefault(
      int key,
      float defaultValue) {

    java.util.Map<java.lang.Integer, java.lang.Float> map =
        internalGetUint32ToFloat().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
   */
  @java.lang.Override
  public float getUint32ToFloatOrThrow(
      int key) {

    java.util.Map<java.lang.Integer, java.lang.Float> map =
        internalGetUint32ToFloat().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int FIXED64_TO_DOUBLE_FIELD_NUMBER = 8;
  private static final class Fixed64ToDoubleDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.Long, java.lang.Double> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.Long, java.lang.Double>newDefaultInstance(
                com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_Fixed64ToDoubleEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.FIXED64,
                0L,
                com.google.protobuf.WireFormat.FieldType.DOUBLE,
                0D);
  }
  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<
      java.lang.Long, java.lang.Double> fixed64ToDouble_;
  private com.google.protobuf.MapField<java.lang.Long, java.lang.Double>
  internalGetFixed64ToDouble() {
    if (fixed64ToDouble_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          Fixed64ToDoubleDefaultEntryHolder.defaultEntry);
    }
    return fixed64ToDouble_;
  }
  public int getFixed64ToDoubleCount() {
    return internalGetFixed64ToDouble().getMap().size();
  }
  /**
   * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
   */
  @java.lang.Override
  public boolean containsFixed64ToDouble(
      long key) {

    return internalGetFixed64ToDouble().getMap().containsKey(key);
  }
  /**
   * Use {@link #getFixed64ToDoubleMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Long, java.lang.Double> getFixed64ToDouble() {
    return getFixed64ToDoubleMap();
  }
  /**
   * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.Long, java.lang.Double> getFixed64ToDoubleMap() {
    return internalGetFixed64ToDouble().getMap();
  }
  /**
   * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
   */
  @java.lang.Override
  public double getFixed64ToDoubleOrDefault(
      long key,
      double defaultValue) {

    java.util.Map<java.lang.Long, java.lang.Double> map =
        internalGetFixed64ToDouble().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
   */
  @java.lang.Override
  public double getFixed64ToDoubleOrThrow(
      long key) {

    java.util.Map<java.lang.Long, java.lang.Double> map =
        internalGetFixed64ToDouble().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessage
        .parseWithIOException(PARSER, input);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessage
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessage
        .parseDelimitedWithIOException(PARSER, input);
  }

  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessage
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessage
        .parseWithIOException(PARSER, input);
  }
  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessage
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Message with map fields (proto3)
   * </pre>
   *
   * Protobuf type {@code ComprehensiveTest.V3.MapMessageV3}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessage.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:ComprehensiveTest.V3.MapMessageV3)
      com.rubberjam.protobuf.compiler.test.v3.MapMessageV3OrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetStringToInt32();
        case 2:
          return internalGetInt32ToString();
        case 3:
          return internalGetStringToEnum();
        case 4:
          return internalGetStringToMessage();
        case 5:
          return internalGetBoolToString();
        case 6:
          return internalGetInt64ToBytes();
        case 7:
          return internalGetUint32ToFloat();
        case 8:
          return internalGetFixed64ToDouble();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetMutableStringToInt32();
        case 2:
          return internalGetMutableInt32ToString();
        case 3:
          return internalGetMutableStringToEnum();
        case 4:
          return internalGetMutableStringToMessage();
        case 5:
          return internalGetMutableBoolToString();
        case 6:
          return internalGetMutableInt64ToBytes();
        case 7:
          return internalGetMutableUint32ToFloat();
        case 8:
          return internalGetMutableFixed64ToDouble();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.rubberjam.protobuf.compiler.test.v3.MapMessageV3.class, com.rubberjam.protobuf.compiler.test.v3.MapMessageV3.Builder.class);
    }

    // Construct using com.rubberjam.protobuf.compiler.test.v3.MapMessageV3.newBuilder()
    private Builder() {

    }

    private Builder(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      super(parent);

    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      internalGetMutableStringToInt32().clear();
      internalGetMutableInt32ToString().clear();
      internalGetMutableStringToEnum().clear();
      internalGetMutableStringToMessage().clear();
      internalGetMutableBoolToString().clear();
      internalGetMutableInt64ToBytes().clear();
      internalGetMutableUint32ToFloat().clear();
      internalGetMutableFixed64ToDouble().clear();
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.rubberjam.protobuf.compiler.test.v3.ComprehensiveTestV3.internal_static_ComprehensiveTest_V3_MapMessageV3_descriptor;
    }

    @java.lang.Override
    public com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 getDefaultInstanceForType() {
      return com.rubberjam.protobuf.compiler.test.v3.MapMessageV3.getDefaultInstance();
    }

    @java.lang.Override
    public com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 build() {
      com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 buildPartial() {
      com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 result = new com.rubberjam.protobuf.compiler.test.v3.MapMessageV3(this);
      if (bitField0_ != 0) { buildPartial0(result); }
      onBuilt();
      return result;
    }

    private void buildPartial0(com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.stringToInt32_ = internalGetStringToInt32();
        result.stringToInt32_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.int32ToString_ = internalGetInt32ToString();
        result.int32ToString_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.stringToEnum_ = internalGetStringToEnum();
        result.stringToEnum_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.stringToMessage_ = internalGetStringToMessage().build(StringToMessageDefaultEntryHolder.defaultEntry);
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.boolToString_ = internalGetBoolToString();
        result.boolToString_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.int64ToBytes_ = internalGetInt64ToBytes();
        result.int64ToBytes_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.uint32ToFloat_ = internalGetUint32ToFloat();
        result.uint32ToFloat_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.fixed64ToDouble_ = internalGetFixed64ToDouble();
        result.fixed64ToDouble_.makeImmutable();
      }
    }

    private int bitField0_;

    private com.google.protobuf.MapField<
        java.lang.String, java.lang.Integer> stringToInt32_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.Integer>
        internalGetStringToInt32() {
      if (stringToInt32_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            StringToInt32DefaultEntryHolder.defaultEntry);
      }
      return stringToInt32_;
    }
    private com.google.protobuf.MapField<java.lang.String, java.lang.Integer>
        internalGetMutableStringToInt32() {
      if (stringToInt32_ == null) {
        stringToInt32_ = com.google.protobuf.MapField.newMapField(
            StringToInt32DefaultEntryHolder.defaultEntry);
      }
      if (!stringToInt32_.isMutable()) {
        stringToInt32_ = stringToInt32_.copy();
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return stringToInt32_;
    }
    public int getStringToInt32Count() {
      return internalGetStringToInt32().getMap().size();
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    @java.lang.Override
    public boolean containsStringToInt32(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetStringToInt32().getMap().containsKey(key);
    }
    /**
     * Use {@link #getStringToInt32Map()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32() {
      return getStringToInt32Map();
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32Map() {
      return internalGetStringToInt32().getMap();
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    @java.lang.Override
    public int getStringToInt32OrDefault(
        java.lang.String key,
        int defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToInt32().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    @java.lang.Override
    public int getStringToInt32OrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToInt32().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearStringToInt32() {
      bitField0_ = (bitField0_ & ~0x00000001);
      internalGetMutableStringToInt32().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    public Builder removeStringToInt32(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      internalGetMutableStringToInt32().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer>
        getMutableStringToInt32() {
      bitField0_ |= 0x00000001;
      return internalGetMutableStringToInt32().getMutableMap();
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    public Builder putStringToInt32(
        java.lang.String key,
        int value) {
      if (key == null) { throw new NullPointerException("map key"); }

      internalGetMutableStringToInt32().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000001;
      return this;
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32 = 1;</code>
     */
    public Builder putAllStringToInt32(
        java.util.Map<java.lang.String, java.lang.Integer> values) {
      internalGetMutableStringToInt32().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000001;
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.Integer, java.lang.String> int32ToString_;
    private com.google.protobuf.MapField<java.lang.Integer, java.lang.String>
        internalGetInt32ToString() {
      if (int32ToString_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            Int32ToStringDefaultEntryHolder.defaultEntry);
      }
      return int32ToString_;
    }
    private com.google.protobuf.MapField<java.lang.Integer, java.lang.String>
        internalGetMutableInt32ToString() {
      if (int32ToString_ == null) {
        int32ToString_ = com.google.protobuf.MapField.newMapField(
            Int32ToStringDefaultEntryHolder.defaultEntry);
      }
      if (!int32ToString_.isMutable()) {
        int32ToString_ = int32ToString_.copy();
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return int32ToString_;
    }
    public int getInt32ToStringCount() {
      return internalGetInt32ToString().getMap().size();
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    @java.lang.Override
    public boolean containsInt32ToString(
        int key) {

      return internalGetInt32ToString().getMap().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToStringMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToString() {
      return getInt32ToStringMap();
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToStringMap() {
      return internalGetInt32ToString().getMap();
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getInt32ToStringOrDefault(
        int key,
        /* nullable */
java.lang.String defaultValue) {

      java.util.Map<java.lang.Integer, java.lang.String> map =
          internalGetInt32ToString().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    @java.lang.Override
    public java.lang.String getInt32ToStringOrThrow(
        int key) {

      java.util.Map<java.lang.Integer, java.lang.String> map =
          internalGetInt32ToString().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearInt32ToString() {
      bitField0_ = (bitField0_ & ~0x00000002);
      internalGetMutableInt32ToString().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    public Builder removeInt32ToString(
        int key) {

      internalGetMutableInt32ToString().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.String>
        getMutableInt32ToString() {
      bitField0_ |= 0x00000002;
      return internalGetMutableInt32ToString().getMutableMap();
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    public Builder putInt32ToString(
        int key,
        java.lang.String value) {

      if (value == null) { throw new NullPointerException("map value"); }
      internalGetMutableInt32ToString().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000002;
      return this;
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string = 2;</code>
     */
    public Builder putAllInt32ToString(
        java.util.Map<java.lang.Integer, java.lang.String> values) {
      internalGetMutableInt32ToString().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000002;
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.String, java.lang.Integer> stringToEnum_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.Integer>
        internalGetStringToEnum() {
      if (stringToEnum_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            StringToEnumDefaultEntryHolder.defaultEntry);
      }
      return stringToEnum_;
    }
    private com.google.protobuf.MapField<java.lang.String, java.lang.Integer>
        internalGetMutableStringToEnum() {
      if (stringToEnum_ == null) {
        stringToEnum_ = com.google.protobuf.MapField.newMapField(
            StringToEnumDefaultEntryHolder.defaultEntry);
      }
      if (!stringToEnum_.isMutable()) {
        stringToEnum_ = stringToEnum_.copy();
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return stringToEnum_;
    }
    public int getStringToEnumCount() {
      return internalGetStringToEnum().getMap().size();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public boolean containsStringToEnum(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetStringToEnum().getMap().containsKey(key);
    }
    /**
     * Use {@link #getStringToEnumMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3>
    getStringToEnum() {
      return getStringToEnumMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3>
    getStringToEnumMap() {
      return internalGetAdaptedStringToEnumMap(
          internalGetStringToEnum().getMap());}
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public /* nullable */
com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 getStringToEnumOrDefault(
        java.lang.String key,
        /* nullable */
com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToEnum().getMap();
      return map.containsKey(key)
             ? stringToEnumValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 getStringToEnumOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToEnum().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return stringToEnumValueConverter.doForward(map.get(key));
    }
    /**
     * Use {@link #getStringToEnumValueMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer>
    getStringToEnumValue() {
      return getStringToEnumValueMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.Integer>
    getStringToEnumValueMap() {
      return internalGetStringToEnum().getMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public int getStringToEnumValueOrDefault(
        java.lang.String key,
        int defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToEnum().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    @java.lang.Override
    public int getStringToEnumValueOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToEnum().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearStringToEnum() {
      bitField0_ = (bitField0_ & ~0x00000004);
      internalGetMutableStringToEnum().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    public Builder removeStringToEnum(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      internalGetMutableStringToEnum().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3>
        getMutableStringToEnum() {
      bitField0_ |= 0x00000004;
      return internalGetAdaptedStringToEnumMap(
           internalGetMutableStringToEnum().getMutableMap());
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    public Builder putStringToEnum(
        java.lang.String key,
        com.rubberjam.protobuf.compiler.test.v3.TestEnumV3 value) {
      if (key == null) { throw new NullPointerException("map key"); }

      internalGetMutableStringToEnum().getMutableMap()
          .put(key, stringToEnumValueConverter.doBackward(value));
      bitField0_ |= 0x00000004;
      return this;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    public Builder putAllStringToEnum(
        java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.TestEnumV3> values) {
      internalGetAdaptedStringToEnumMap(
          internalGetMutableStringToEnum().getMutableMap())
              .putAll(values);
      bitField0_ |= 0x00000004;
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer>
    getMutableStringToEnumValue() {
      bitField0_ |= 0x00000004;
      return internalGetMutableStringToEnum().getMutableMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    public Builder putStringToEnumValue(
        java.lang.String key,
        int value) {
      if (key == null) { throw new NullPointerException("map key"); }

      internalGetMutableStringToEnum().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000004;
      return this;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.TestEnumV3&gt; string_to_enum = 3;</code>
     */
    public Builder putAllStringToEnumValue(
        java.util.Map<java.lang.String, java.lang.Integer> values) {
      internalGetMutableStringToEnum().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000004;
      return this;
    }

    private static final class StringToMessageConverter implements com.google.protobuf.MapFieldBuilder.Converter<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> {
      @java.lang.Override
      public com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 build(com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder val) {
        if (val instanceof com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3) { return (com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3) val; }
        return ((com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.Builder) val).build();
      }

      @java.lang.Override
      public com.google.protobuf.MapEntry<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> defaultEntry() {
        return StringToMessageDefaultEntryHolder.defaultEntry;
      }
    };
    private static final StringToMessageConverter stringToMessageConverter = new StringToMessageConverter();

    private com.google.protobuf.MapFieldBuilder<
        java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.Builder> stringToMessage_;
    private com.google.protobuf.MapFieldBuilder<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.Builder>
        internalGetStringToMessage() {
      if (stringToMessage_ == null) {
        return new com.google.protobuf.MapFieldBuilder<>(stringToMessageConverter);
      }
      return stringToMessage_;
    }
    private com.google.protobuf.MapFieldBuilder<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.Builder>
        internalGetMutableStringToMessage() {
      if (stringToMessage_ == null) {
        stringToMessage_ = new com.google.protobuf.MapFieldBuilder<>(stringToMessageConverter);
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return stringToMessage_;
    }
    public int getStringToMessageCount() {
      return internalGetStringToMessage().ensureBuilderMap().size();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    @java.lang.Override
    public boolean containsStringToMessage(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetStringToMessage().ensureBuilderMap().containsKey(key);
    }
    /**
     * Use {@link #getStringToMessageMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> getStringToMessage() {
      return getStringToMessageMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> getStringToMessageMap() {
      return internalGetStringToMessage().getImmutableMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    @java.lang.Override
    public /* nullable */
com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 getStringToMessageOrDefault(
        java.lang.String key,
        /* nullable */
com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder> map = internalGetMutableStringToMessage().ensureBuilderMap();
      return map.containsKey(key) ? stringToMessageConverter.build(map.get(key)) : defaultValue;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    @java.lang.Override
    public com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 getStringToMessageOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder> map = internalGetMutableStringToMessage().ensureBuilderMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return stringToMessageConverter.build(map.get(key));
    }
    public Builder clearStringToMessage() {
      bitField0_ = (bitField0_ & ~0x00000008);
      internalGetMutableStringToMessage().clear();
      return this;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    public Builder removeStringToMessage(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      internalGetMutableStringToMessage().ensureBuilderMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3>
        getMutableStringToMessage() {
      bitField0_ |= 0x00000008;
      return internalGetMutableStringToMessage().ensureMessageMap();
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    public Builder putStringToMessage(
        java.lang.String key,
        com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3 value) {
      if (key == null) { throw new NullPointerException("map key"); }
      if (value == null) { throw new NullPointerException("map value"); }
      internalGetMutableStringToMessage().ensureBuilderMap()
          .put(key, value);
      bitField0_ |= 0x00000008;
      return this;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    public Builder putAllStringToMessage(
        java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> values) {
      for (java.util.Map.Entry<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3> e : values.entrySet()) {
        if (e.getKey() == null || e.getValue() == null) {
          throw new NullPointerException();
        }
      }
      internalGetMutableStringToMessage().ensureBuilderMap()
          .putAll(values);
      bitField0_ |= 0x00000008;
      return this;
    }
    /**
     * <code>map&lt;string, .ComprehensiveTest.V3.AllFieldTypesV3&gt; string_to_message = 4;</code>
     */
    public com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.Builder putStringToMessageBuilderIfAbsent(
        java.lang.String key) {
      java.util.Map<java.lang.String, com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder> builderMap = internalGetMutableStringToMessage().ensureBuilderMap();
      com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3OrBuilder entry = builderMap.get(key);
      if (entry == null) {
        entry = com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.newBuilder();
        builderMap.put(key, entry);
      }
      if (entry instanceof com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3) {
        entry = ((com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3) entry).toBuilder();
        builderMap.put(key, entry);
      }
      return (com.rubberjam.protobuf.compiler.test.v3.AllFieldTypesV3.Builder) entry;
    }

    private com.google.protobuf.MapField<
        java.lang.Boolean, java.lang.String> boolToString_;
    private com.google.protobuf.MapField<java.lang.Boolean, java.lang.String>
        internalGetBoolToString() {
      if (boolToString_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            BoolToStringDefaultEntryHolder.defaultEntry);
      }
      return boolToString_;
    }
    private com.google.protobuf.MapField<java.lang.Boolean, java.lang.String>
        internalGetMutableBoolToString() {
      if (boolToString_ == null) {
        boolToString_ = com.google.protobuf.MapField.newMapField(
            BoolToStringDefaultEntryHolder.defaultEntry);
      }
      if (!boolToString_.isMutable()) {
        boolToString_ = boolToString_.copy();
      }
      bitField0_ |= 0x00000010;
      onChanged();
      return boolToString_;
    }
    public int getBoolToStringCount() {
      return internalGetBoolToString().getMap().size();
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    @java.lang.Override
    public boolean containsBoolToString(
        boolean key) {

      return internalGetBoolToString().getMap().containsKey(key);
    }
    /**
     * Use {@link #getBoolToStringMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Boolean, java.lang.String> getBoolToString() {
      return getBoolToStringMap();
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Boolean, java.lang.String> getBoolToStringMap() {
      return internalGetBoolToString().getMap();
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getBoolToStringOrDefault(
        boolean key,
        /* nullable */
java.lang.String defaultValue) {

      java.util.Map<java.lang.Boolean, java.lang.String> map =
          internalGetBoolToString().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    @java.lang.Override
    public java.lang.String getBoolToStringOrThrow(
        boolean key) {

      java.util.Map<java.lang.Boolean, java.lang.String> map =
          internalGetBoolToString().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearBoolToString() {
      bitField0_ = (bitField0_ & ~0x00000010);
      internalGetMutableBoolToString().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    public Builder removeBoolToString(
        boolean key) {

      internalGetMutableBoolToString().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Boolean, java.lang.String>
        getMutableBoolToString() {
      bitField0_ |= 0x00000010;
      return internalGetMutableBoolToString().getMutableMap();
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    public Builder putBoolToString(
        boolean key,
        java.lang.String value) {

      if (value == null) { throw new NullPointerException("map value"); }
      internalGetMutableBoolToString().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000010;
      return this;
    }
    /**
     * <code>map&lt;bool, string&gt; bool_to_string = 5;</code>
     */
    public Builder putAllBoolToString(
        java.util.Map<java.lang.Boolean, java.lang.String> values) {
      internalGetMutableBoolToString().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000010;
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.Long, com.google.protobuf.ByteString> int64ToBytes_;
    private com.google.protobuf.MapField<java.lang.Long, com.google.protobuf.ByteString>
        internalGetInt64ToBytes() {
      if (int64ToBytes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            Int64ToBytesDefaultEntryHolder.defaultEntry);
      }
      return int64ToBytes_;
    }
    private com.google.protobuf.MapField<java.lang.Long, com.google.protobuf.ByteString>
        internalGetMutableInt64ToBytes() {
      if (int64ToBytes_ == null) {
        int64ToBytes_ = com.google.protobuf.MapField.newMapField(
            Int64ToBytesDefaultEntryHolder.defaultEntry);
      }
      if (!int64ToBytes_.isMutable()) {
        int64ToBytes_ = int64ToBytes_.copy();
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return int64ToBytes_;
    }
    public int getInt64ToBytesCount() {
      return internalGetInt64ToBytes().getMap().size();
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    @java.lang.Override
    public boolean containsInt64ToBytes(
        long key) {

      return internalGetInt64ToBytes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getInt64ToBytesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getInt64ToBytes() {
      return getInt64ToBytesMap();
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getInt64ToBytesMap() {
      return internalGetInt64ToBytes().getMap();
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    @java.lang.Override
    public /* nullable */
com.google.protobuf.ByteString getInt64ToBytesOrDefault(
        long key,
        /* nullable */
com.google.protobuf.ByteString defaultValue) {

      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetInt64ToBytes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getInt64ToBytesOrThrow(
        long key) {

      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetInt64ToBytes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearInt64ToBytes() {
      bitField0_ = (bitField0_ & ~0x00000020);
      internalGetMutableInt64ToBytes().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    public Builder removeInt64ToBytes(
        long key) {

      internalGetMutableInt64ToBytes().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
        getMutableInt64ToBytes() {
      bitField0_ |= 0x00000020;
      return internalGetMutableInt64ToBytes().getMutableMap();
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    public Builder putInt64ToBytes(
        long key,
        com.google.protobuf.ByteString value) {

      if (value == null) { throw new NullPointerException("map value"); }
      internalGetMutableInt64ToBytes().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000020;
      return this;
    }
    /**
     * <code>map&lt;int64, bytes&gt; int64_to_bytes = 6;</code>
     */
    public Builder putAllInt64ToBytes(
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> values) {
      internalGetMutableInt64ToBytes().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000020;
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.Integer, java.lang.Float> uint32ToFloat_;
    private com.google.protobuf.MapField<java.lang.Integer, java.lang.Float>
        internalGetUint32ToFloat() {
      if (uint32ToFloat_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            Uint32ToFloatDefaultEntryHolder.defaultEntry);
      }
      return uint32ToFloat_;
    }
    private com.google.protobuf.MapField<java.lang.Integer, java.lang.Float>
        internalGetMutableUint32ToFloat() {
      if (uint32ToFloat_ == null) {
        uint32ToFloat_ = com.google.protobuf.MapField.newMapField(
            Uint32ToFloatDefaultEntryHolder.defaultEntry);
      }
      if (!uint32ToFloat_.isMutable()) {
        uint32ToFloat_ = uint32ToFloat_.copy();
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return uint32ToFloat_;
    }
    public int getUint32ToFloatCount() {
      return internalGetUint32ToFloat().getMap().size();
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    @java.lang.Override
    public boolean containsUint32ToFloat(
        int key) {

      return internalGetUint32ToFloat().getMap().containsKey(key);
    }
    /**
     * Use {@link #getUint32ToFloatMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.Float> getUint32ToFloat() {
      return getUint32ToFloatMap();
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Integer, java.lang.Float> getUint32ToFloatMap() {
      return internalGetUint32ToFloat().getMap();
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    @java.lang.Override
    public float getUint32ToFloatOrDefault(
        int key,
        float defaultValue) {

      java.util.Map<java.lang.Integer, java.lang.Float> map =
          internalGetUint32ToFloat().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    @java.lang.Override
    public float getUint32ToFloatOrThrow(
        int key) {

      java.util.Map<java.lang.Integer, java.lang.Float> map =
          internalGetUint32ToFloat().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearUint32ToFloat() {
      bitField0_ = (bitField0_ & ~0x00000040);
      internalGetMutableUint32ToFloat().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    public Builder removeUint32ToFloat(
        int key) {

      internalGetMutableUint32ToFloat().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.Float>
        getMutableUint32ToFloat() {
      bitField0_ |= 0x00000040;
      return internalGetMutableUint32ToFloat().getMutableMap();
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    public Builder putUint32ToFloat(
        int key,
        float value) {


      internalGetMutableUint32ToFloat().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000040;
      return this;
    }
    /**
     * <code>map&lt;uint32, float&gt; uint32_to_float = 7;</code>
     */
    public Builder putAllUint32ToFloat(
        java.util.Map<java.lang.Integer, java.lang.Float> values) {
      internalGetMutableUint32ToFloat().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000040;
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.Long, java.lang.Double> fixed64ToDouble_;
    private com.google.protobuf.MapField<java.lang.Long, java.lang.Double>
        internalGetFixed64ToDouble() {
      if (fixed64ToDouble_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            Fixed64ToDoubleDefaultEntryHolder.defaultEntry);
      }
      return fixed64ToDouble_;
    }
    private com.google.protobuf.MapField<java.lang.Long, java.lang.Double>
        internalGetMutableFixed64ToDouble() {
      if (fixed64ToDouble_ == null) {
        fixed64ToDouble_ = com.google.protobuf.MapField.newMapField(
            Fixed64ToDoubleDefaultEntryHolder.defaultEntry);
      }
      if (!fixed64ToDouble_.isMutable()) {
        fixed64ToDouble_ = fixed64ToDouble_.copy();
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return fixed64ToDouble_;
    }
    public int getFixed64ToDoubleCount() {
      return internalGetFixed64ToDouble().getMap().size();
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    @java.lang.Override
    public boolean containsFixed64ToDouble(
        long key) {

      return internalGetFixed64ToDouble().getMap().containsKey(key);
    }
    /**
     * Use {@link #getFixed64ToDoubleMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, java.lang.Double> getFixed64ToDouble() {
      return getFixed64ToDoubleMap();
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Long, java.lang.Double> getFixed64ToDoubleMap() {
      return internalGetFixed64ToDouble().getMap();
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    @java.lang.Override
    public double getFixed64ToDoubleOrDefault(
        long key,
        double defaultValue) {

      java.util.Map<java.lang.Long, java.lang.Double> map =
          internalGetFixed64ToDouble().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    @java.lang.Override
    public double getFixed64ToDoubleOrThrow(
        long key) {

      java.util.Map<java.lang.Long, java.lang.Double> map =
          internalGetFixed64ToDouble().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    public Builder clearFixed64ToDouble() {
      bitField0_ = (bitField0_ & ~0x00000080);
      internalGetMutableFixed64ToDouble().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    public Builder removeFixed64ToDouble(
        long key) {

      internalGetMutableFixed64ToDouble().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, java.lang.Double>
        getMutableFixed64ToDouble() {
      bitField0_ |= 0x00000080;
      return internalGetMutableFixed64ToDouble().getMutableMap();
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    public Builder putFixed64ToDouble(
        long key,
        double value) {


      internalGetMutableFixed64ToDouble().getMutableMap()
          .put(key, value);
      bitField0_ |= 0x00000080;
      return this;
    }
    /**
     * <code>map&lt;fixed64, double&gt; fixed64_to_double = 8;</code>
     */
    public Builder putAllFixed64ToDouble(
        java.util.Map<java.lang.Long, java.lang.Double> values) {
      internalGetMutableFixed64ToDouble().getMutableMap()
          .putAll(values);
      bitField0_ |= 0x00000080;
      return this;
    }

    // @@protoc_insertion_point(builder_scope:ComprehensiveTest.V3.MapMessageV3)
  }

  // @@protoc_insertion_point(class_scope:ComprehensiveTest.V3.MapMessageV3)
  private static final com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.rubberjam.protobuf.compiler.test.v3.MapMessageV3();
  }

  public static com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<MapMessageV3>
      PARSER = new com.google.protobuf.AbstractParser<MapMessageV3>() {
    @java.lang.Override
    public MapMessageV3 parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      Builder builder = newBuilder();
      try {
        builder.mergeFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(builder.buildPartial());
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e)
            .setUnfinishedMessage(builder.buildPartial());
      }
      return builder.buildPartial();
    }
  };

  public static com.google.protobuf.Parser<MapMessageV3> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<MapMessageV3> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.rubberjam.protobuf.compiler.test.v3.MapMessageV3 getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

